{"ast":null,"code":"import { __awaiter, __decorate } from \"tslib\";\nimport { Injectable } from '@angular/core';\nimport { AbkBedeutung } from './abk-bedeutung';\n/**\r\n * Service-Klasse kapselt Persistenz mit [ionic-storage]( https://ionicframework.com/docs/angular/storage#ionic-storage ).\r\n * <br><br>\r\n *\r\n * \"ionic-storage\" Projekt hinzufügen: `npm install --save @ionic/storage`\r\n * <br><br>\r\n *\r\n * \"ionic storage\" stellt einen Key-Value-Speicher zu Verfügung.\r\n * Wir verwenden die Abkürzungen (nach Normierung auf Großbuchstaben) als Key,\r\n * die Bedeutung(en) wird/werden unter diesem Key bespeichert.\r\n * <br><br>\r\n *\r\n * Beispiele:\r\n * * \"OOO\": [ \"Out of Office\", \"Out of Order\" ]\r\n * * \"AVD\": [ \"Android Virtual Device (Emulator-Instanz\" ]\r\n */\n\nlet SpeicherService = class SpeicherService {\n  /**\r\n   * Konstruktor für Dependency Injection.\r\n   */\n  constructor(storage) {\n    this.storage = storage;\n  }\n  /**\r\n   * Getter für Gesamtanzahl der gespeicherten Abkürzungen (eine Abkürzung\r\n   * kann aber mehr als eine Bedeutung haben).\r\n   *\r\n   * @return  Promise mit Anzahl der aktuell gespeicherten Abkürzungen.\r\n   */\n\n\n  getAnzahlGespeicherteAbkuerzungen() {\n    let anzahlPromise = this.storage.length();\n    return anzahlPromise;\n  }\n  /**\r\n   * Sucht nach Bedeutungen für die als Argument übergebene Abkürzung. Es können keine, eine\r\n   * oder mehrere Bedeutungen für eine Abkürzung gefunden werden.\r\n   *\r\n   * @param abkuerzung   Abkürzung, für die nach Bedeutungen gesucht werden soll.\r\n   *\r\n   * @return  Promise mit String-Array, der die für die Abkürzung gefunden Bedeutungen enthält.\r\n   *          Wenn keine Bedeutungen für die Abkürzung gefunden wurden, dann ist der Wert `null`\r\n   *          (aber kein Promise, der in Zustand \"rejected\" auflöst).\r\n   */\n\n\n  holeBedeutungenFuerAbk(abkuerzung) {\n    const abkuerzungNormiert = abkuerzung.trim().toUpperCase();\n    const anyPromise = this.storage.get(abkuerzungNormiert);\n    return anyPromise;\n  }\n  /**\r\n   * Abkürzung und Bedeutung speichern. Wenn für die Abkürzung noch kein Bedeutung gespeichert\r\n   * ist, dann wird der Eintrag ganz neu angelegt. Wenn es schon eine oder mehrere Bedeutungen\r\n   * für die Abkürzung gibt, dann wird die neue Bedeutung zum Array der Bedeutungen hinzufügt.\r\n   *\r\n   * @param abkuerzung  Abkürzung, wird (nach Normierung) als Key verwendet.\r\n   *\r\n   * @param bedeutung  Bedeutung für die Abkürzung, wird (nach Trimming) als Wert verwendet.\r\n   *\r\n   * @return  Promise mit Anzahl der Bedeutungen, die nach Speichern von `bedeutung` für `abkuerzung`\r\n   *          gespeichert sind.\r\n   */\n\n\n  speichereBedeutungFuerAbkuerzung(abkuerzung, bedeutung) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let bedeutungenArrayNeu = null;\n      let bedeutungenArrayAlt = yield this.holeBedeutungenFuerAbk(abkuerzung);\n      const abkuerzungNormiert = abkuerzung.trim().toUpperCase();\n\n      if (bedeutungenArrayAlt === null || bedeutungenArrayAlt === undefined) {\n        // Für die Abkürzung ist noch überhaupt keine Bedeutung gespeichert\n        bedeutungenArrayNeu = [bedeutung];\n        yield this.storage.set(abkuerzungNormiert, bedeutungenArrayNeu);\n        return 1;\n      } else {\n        // Für die Abkürzung war schon mindestens eine Bedeutung abgespeichert\n        bedeutungenArrayNeu = bedeutungenArrayAlt;\n        bedeutungenArrayNeu.push(bedeutung);\n        yield this.storage.set(abkuerzungNormiert, bedeutungenArrayNeu);\n        return bedeutungenArrayNeu.length;\n      }\n    });\n  }\n  /**\r\n   * Methode holt alle Abkürzungen mit jeweils allen Bedeutungen.\r\n   *\r\n   * @return  Promise-Objekt für Array von Objekten. Jedes dieser Objekte enthält unter\r\n   *          dem Schlüssel `abkürzung` die Abkürzung, und unter dem Schüssel `bedeutung`\r\n   *          die zugehörige Bedeutung.\r\n   */\n\n\n  holeAlleAbkuerzungenUndBedeutungen() {\n    const ergebnisPromise = new Promise((resolveCallback, rejectCallback) => {\n      const ergebnisArray = [];\n      this.storage.forEach((wert, schluessel, nummer) => {\n        let abkBedeutung = new AbkBedeutung(schluessel, wert);\n        ergebnisArray.push(abkBedeutung);\n      }).then(() => {\n        resolveCallback(ergebnisArray);\n      });\n    });\n    return ergebnisPromise;\n  }\n  /**\r\n   * Löschen einer Abkürzung mit allen ihren Bedeutungen.\r\n   *\r\n   * @param abkuerzung   Abkürzung, die zu löschen ist.\r\n   */\n\n\n  abkuerzungLoeschen(abkuerzung) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.storage.remove(abkuerzung);\n    });\n  }\n  /**\r\n   * Einzelne Bedeutung einer bestimmten Abkürzung löschen.\r\n   *\r\n   * @param abkuerzung Abkürzung, zu der die zu löschende Bedeutung gehört.\r\n   * @param bedeutung Bedeutung, die gelöscht werden soll.\r\n   */\n\n\n  bedeutungLoeschen(abkuerzung, bedeutung) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Als Übungsaufgabe zu implementieren\n      return \"\";\n    });\n  }\n\n};\nSpeicherService = __decorate([Injectable({\n  providedIn: 'root'\n})], SpeicherService);\nexport { SpeicherService };","map":null,"metadata":{},"sourceType":"module"}